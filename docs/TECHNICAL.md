# 技術アーキテクチャ

技術スタック、アーキテクチャ、パフォーマンス目標、ランキングシステムの設計をまとめます。

> **関連ドキュメント**: 
> - [データ設計](data-design.json) - データ構造・エンティティ定義
> - [企画・ビジネス情報](PLANNING.md) - KPI・マーケティング戦略

---

## 技術アーキテクチャ（概要）

**クライアント: Swift（ネイティブ iOS）**

```
[iOS アプリ: Swift ネイティブ]
   ├─ SwiftUI または UIKit（UI構築）
   ├─ Core Motion（CMMotionManager：加速度・振り検知）
   ├─ Combine / async-await（非同期・データバインディング）
   ├─ AVFoundation（効果音・BGM）
   └─ Firebase iOS SDK（Auth, Firestore, Realtime DB, Analytics）
   ↕ HTTPS / WebSocket
[バックエンド: Firebase]
   ├─ Firestore / Realtime Database（ルーム・ランキング・ユーザーデータ）
   ├─ Cloud Functions（ランキング集計、ルーム管理）
   ├─ Firebase Authentication（匿名 or Sign in with Apple）
   └─ Cloud Storage（プロフィール画像、将来のカスタム缶画像）
```

**採用理由（ネイティブ Swift）**:
- 加速度センサー・ハプティクス・音声を OS に最適化して利用可能
- 液体アニメーション・パーティクルを Metal / Core Animation で 60 FPS 安定
- App Store 審査・配信フローにそのまま乗れる
- **Android 版**は将来 **Kotlin（ネイティブ）** で別プロジェクトとして検討可能

**データモデル**: エンティティ（User, Session, Room, RoomScore, LeaderboardEntry, Season, Drink, UserSettings）、Enum（DrinkType, Rank, RoomStatus, UserTier）、Firestore コレクション・インデックス・リレーションは **`data-design.json`**（同 `docs/` 内）に一括定義。開発時はこの JSON を参照してモデル・API を実装します。

---

## API設計

- `POST /rooms/create` — ルーム作成、roomId 返却
- `POST /rooms/join` — ルームコードで参加
- `POST /sessions/submit` — スコア送信（個人 or ルーム内）
- `GET /leaderboard/global?season=X` — グローバルランキング取得
- `GET /rooms/:roomId/results` — グループ内順位取得

---

## シーズン制ランキングの理由と効果

ランキングを**シーズン（期間）で区切る**理由と、このアプリにもたらす効果をまとめます。

### 理由（なぜシーズンで区切るか）

| 理由 | 説明 |
|------|------|
| **公平性・新規参入のしやすさ** | 常に「全期間の累計」だけだと、昔からプレイしているユーザーが上位を占め続ける。シーズンごとにリセットすることで、**新規ユーザーも「今シーズンなら1位を狙える」**と感じやすく、参入障壁が下がる。 |
| **再プレイの動機づけ** | 「先月は10位だった。今月こそトップ3に入りたい」のように、**毎シーズン「やり直し」ができる**ため、離脱したユーザーが戻ってきたり、週末だけプレイする層が「今シーズンだけは頑張る」と継続しやすくなる。 |
| **終了日による緊急性（FOMO）** | UI の「SEASON ENDS IN 12 HRS 45 MIN 30 SEC」のように**締め切りを明示**すると、「今のうちにスコアを伸ばさないと」という心理が働き、シーズン終盤のプレイ頻度・エンゲージメントが上がる。 |
| **運用・技術のしやすさ** | ランキングが「全期間で1本」だとデータが肥大化し、集計・表示が重くなる。シーズンごとに区切ることで**集計対象を限定**でき、クエリやキャッシュの設計がしやすく、古いデータのアーカイブやリセットも行いやすい。 |
| **イベント・マーケとの連携** | 「1月シーズン」「冬の Fizz 祭」のように**シーズン＝イベント**として扱える。限定缶・報酬・広告と紐づけやすく、SNS やプッシュで「新シーズン開始」を告知する材料になる。 |

### このアプリにもたらす効果

| 効果 | 内容 |
|------|------|
| **リテンションの向上** | 月替わり（または四半期）シーズンにより、「また来月頑張ろう」と**定期的に戻ってくる理由**ができる。KPI の D7/D30 リテンション改善が期待できる。 |
| **新規獲得との両立** | 既存プレイヤーだけでなく、**新規インストールしたユーザーも「今シーズンから」同じ土俵で競える**ため、獲得施策（広告・インフルエンサー）の効果が「ランキング上位を狙える」という訴求で伝わりやすい。 |
| **収益機会** | シーズン限定の缶パック・バッジ・「シーズンパス」などの**課金・広告と紐づけ**やすい。「今シーズン TOP 10 に特典」といったキャンペーンも設計しやすい。 |
| **コミュニティ・話題** | 「今シーズン誰が1位か」「先月の自分 vs 今月の自分」など**会話のネタ**が生まれ、X・Discord での盛り上がりや口コミにつながる。 |
| **バランス変更との相性** | 将来、缶のパラメータ（FIZZ/SPEED/POWER）やランク基準を変更しても、**「新シーズンから新ルール」**と伝えやすく、不満を抑えつつゲーム性を進化させやすい。 |

**まとめ**: シーズン制は「公平性」「再プレイの動機」「締め切りによる緊急性」「運用のしやすさ」「イベント化」を満たし、**リテンション・新規獲得・収益・コミュニティ**に効く設計です。ShakeFizz では月単位（例: 2025-01）を想定し、グローバルランキング画面の「SEASON ENDS IN」表示と連動させます。

---

## ウィークリーランキングとウィークリー1位バッジ（採用案）

期間を**ウィークリー（週単位）**で区切り、**今週1位だったユーザーにバッジを付与**する案を採用します。

| 内容 | 説明 |
|------|------|
| **ウィークリーランキング** | 今週（月曜 0:00〜日曜 23:59 など、UTC または日本時間で週を定義）に記録された Session だけを対象に、「今週のランキング」を表示します。毎週リセットされるので、**「今週こそ1位」**を狙う動機が毎週生まれます。 |
| **ウィークリー1位バッジ** | ある週のグローバル1位だったユーザーに **「Weekly #1」** などのバッジを付与し、プロフィール・ランキング表示・SNSシェア時に表示します。**獲得実績として残る**ので、ウィークリー1位の価値が高まり、週の終盤のプレイ数が伸びやすいです。 |
| **シーズンとの併用** | ウィークリー（今週のランキング・Weekly #1 バッジ）と、月単位シーズン（今月のランキング・「SEASON ENDS IN」）を**両方**用意します。ウィークリー＝短いサイクルで週のうちに開く理由、シーズン＝月末の締め切りとイベント化、という役割分担ができます。 |

**効果**: ウィークリー区切り＋バッジにより、**週のうちにアプリを開く理由**と**シェアしたくなる実績**が増え、リテンション・SNS拡散の両方に効きます。

---

## ランキングを「Session から期間で算出」するか、「別データで保持」するか

「期間（ウィークリー／シーズン）で区切るなら、**Season エンティティや LeaderboardEntry を保持せず、Session をその期間で絞り込んでランキングを算出する**のでは？」という設計も成立します。両方のやり方と、**ランキング用データを保持する理由**を整理します。

### 方式A: Session のみ保持し、ランキングは都度算出

- **やり方**: Season や LeaderboardEntry は持たない。ランキング表示時に「対象期間の Session を取得（例: `timestamp >= 今月1日 AND timestamp < 来月1日`）→ ユーザーごとに最大スコアを集計 → ソートして上位 N 件表示」とする。
- **メリット**: データの重複がない。**集計ロジックが一箇所**で、Session が正しければランキングは常に正しい。ウィークリー・月間など**期間の種類を増やしても、同じ Session に対して別の時間範囲を指定するだけ**で済む。
- **デメリット**: 
  - **読むドキュメント数が膨大になる**: Firestore は「ドキュメント読み取り」で課金される。例えば「今月のランキング TOP 100」を出すために、今月の Session が 10 万件あると、**10 万回読む**ことになり、コスト・レスポンス時間が増大する。
  - **集計が重い**: クライアントや Cloud Functions で「全 Session を読んでグループ化・ソート」する処理が重く、表示が遅くなる。
- **向いている規模**: **ユーザー数・プレイ数が少ないうち（例: ベータ期、日次セッション数が数百〜数千程度）**は、Session を期間で絞ってランキング算出するだけで運用可能。まずは **Session のみでランキングを実装し、負荷が増えてから事前集計に移行**する選択もあり。

### 方式B: ランキング用のデータを別途保持（事前集計）

- **やり方**: 定期的に（例: 毎週月曜 0:05、毎月1日 0:05）Cloud Functions などで「対象期間の Session を集計し、**ウィークリー TOP N / シーズン TOP N を `weekly_leaderboard` や `leaderboard_entries` に書き出す**」。表示時はその**少数ドキュメントだけを読む**。
- **メリット**: 
  - **読み取りコスト・レスポンスが小さい**: ランキング画面を開くたびに「TOP 100 の 100 件」だけ読めばよい。Session を何万件も読まない。
  - **「締め切り」との整合**: ウィークリー 1 位やシーズン終了時点の順位を**確定した値**として保持できる。バッジ付与（「その週の 1 位」）も、確定済みのランキングテーブルを参照すればよい。
- **デメリット**: 集計ジョブの実装・運用が必要。集計の遅延（例: 5 分遅れ）を許容するか、リアルタイムに近づけるかは設計次第。

### Season エンティティを「持つ／持たない」

- **持たない場合**: 「今シーズン＝今月」「今シーズン終了＝月末 23:59」などを**アプリ側のルール（コード）で固定**する。`SEASON ENDS IN` は「月末までの残り時間」をクライアントで計算すればよい。**Season ドキュメントは必須ではない**。
- **持つ場合**: シーズン期間を DB で管理したいとき（例: イベントで「今週だけ 2 週間シーズン」にする）は、`Season` エンティティで `startsAt` / `endsAt` を保持し、`SEASON ENDS IN` や「どのシーズンのランキングか」の判定に使う。**運用で期間を変えたいとき**に有利。

### 結論（ShakeFizz での推奨）

| フェーズ | 推奨 |
|----------|------|
| **初期・小規模** | **Session のみ保持**。ウィークリー／シーズンとも「その期間の Session を取得 → ユーザーごと最大スコアで集計 → ランキング表示」。Season エンティティは持たず、期間はコードで「今週」「今月」と定義。ウィークリー 1 位バッジは「その週のランキング 1 位」を表示時に算出するか、週次バッチで 1 位の uid を User のバッジとして 1 件だけ書き込む軽い集計でもよい。 |
| **規模が大きくなったら** | ランキング表示の読み取りコスト・遅延を抑えるため、**ウィークリー TOP N・シーズン TOP N を事前集計して保持**（例: `weekly_leaderboard/{weekId}`, `leaderboard_entries`）。ウィークリー 1 位バッジも、この確定ランキングを元に付与する。Season は「期間を運用で変えたいとき」だけ導入する。 |

**まとめ**: 「期間で区切る」ために **Season や LeaderboardEntry を必ず持つ必要はない**。**Session を期間で絞ってランキングを算出する設計でよい**。ランキング用データを別途保持するのは、**読み取りコスト・レスポンス・確定順位・バッジ付与**を楽にするためであり、**スケールに応じて「まず Session のみ → 負荷が増えたら事前集計」と段階的に選べる**。

---

## 音響・ハプティクス設計

| 要素 | 音・振動 | タイミング |
|------|----------|------------|
| **UI音** | タップ音（シュッ）、ページ遷移（ウィン） | ボタンタップ、画面切り替え |
| **カウントダウン** | 「3」「2」「1」（ビープ音）→「GO!」（高音+重低音） | プレイ開始前 |
| **シェイク検知** | シュワシュワ音（液体・炭酸音）、強さに応じて音量・ピッチ変化 | プレイ中、振り続けている間 |
| **内圧上昇** | プシュー音（圧力）、HIGH PRESSURE 時は連続音 | 一定の振り強度を超えたとき |
| **噴射（POP THE TOP）** | 爆発音 + シューッ（噴き出し）、ハプティクス: 強い振動（0.5秒） | 「POP THE TOP」タップ時 |
| **結果表示** | ランクに応じた音: S=ファンファーレ、A=拍手、B/C=短い効果音 | 結果画面表示時 |
| **NEW RECORD** | キラキラ音 + 短い振動 | 自己ベスト更新時 |
| **BGM** | オプション: ループ可能なネオン感のある EDM 風（プレイ中のみ、設定でON/OFF） | プレイ画面 |

**設定**: 音量・ハプティクス強度は設定画面で調整可能（OFF含む）。

---

## パフォーマンス目標

| 指標 | 目標値 |
|------|--------|
| 起動時間 | 冷起動 < 2.5秒（スプラッシュ→飲み物選択） |
| FPS（プレイ画面） | 60 FPS 維持（液体アニメーション・パーティクル動作中） |
| バッテリー消費 | 10分プレイで < 3%（平均的なスマホ） |
| アプリサイズ | 初回 DL < 80 MB、OTA更新 < 20 MB |
| メモリ使用量 | < 200 MB（iOS） |
| ネットワーク | スコア送信・ランキング取得は各 < 500ms。オフラインでも単体プレイ可能（スコア送信は再接続時） |

---

## 多言語対応（ローカライゼーション）

| 言語 | 対応優先度 | 備考 |
|------|------------|------|
| 日本語 | ⭐⭐⭐ | プライマリ |
| 英語 | ⭐⭐⭐ | グローバル展開必須 |
| 中国語（簡体字） | ⭐⭐ | アジア圏拡大時 |
| 韓国語 | ⭐⭐ | アジア圏拡大時 |
| その他（スペイン語・フランス語など） | ⭐ | 需要に応じて |

**実装**: Swift 標準の **Localizable.strings**（`ja.lproj`, `en.lproj`）と **NSLocalizedString** / **String(localized:)** で UI 文言・通知を管理。SwiftUI の場合は `Text("key", tableName: "Localizable")` または `LocalizedStringKey` を利用します。

---

*データ構造の詳細については [data-design.json](data-design.json) を参照してください。*
